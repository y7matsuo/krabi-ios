schema {
  query: Query
  mutation: Mutation
}
"An ISO 8601-encoded datetime"
scalar ISO8601DateTime
type Account {
  accountType: AccountCategory
  createdAt: ISO8601DateTime!
  email: String
  id: Int
  password: String
  status: ActiveCategory
  updatedAt: ISO8601DateTime!
  user: User
}
"The connection type for Account."
type AccountConnection {
  "A list of edges."
  edges: [AccountEdge]
  "A list of nodes."
  nodes: [Account]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AccountEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Account
}
"Autogenerated return type of CreateRelationMutation"
type CreateRelationMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  relation: Relation
}
"Autogenerated return type of CreateTalkMutation"
type CreateTalkMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  talk: Talk
}
"Autogenerated return type of LoginMutation"
type LoginMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  token: String
  userId: Int
}
"Autogenerated return type of LogoutMutation"
type LogoutMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  message: String
}
type Mutation {
  createRelation(
    "Parameters for CreateRelationMutation"
    input: CreateRelationMutationInput!
  ): CreateRelationMutationPayload
  createTalk(
    "Parameters for CreateTalkMutation"
    input: CreateTalkMutationInput!
  ): CreateTalkMutationPayload
  login(
    "Parameters for LoginMutation"
    input: LoginMutationInput!
  ): LoginMutationPayload
  logout(
    "Parameters for LogoutMutation"
    input: LogoutMutationInput!
  ): LogoutMutationPayload
  updateRelation(
    "Parameters for UpdateRelationMutation"
    input: UpdateRelationMutationInput!
  ): UpdateRelationMutationPayload
  updateTalk(
    "Parameters for UpdateTalkMutation"
    input: UpdateTalkMutationInput!
  ): UpdateTalkMutationPayload
  updateUser(
    "Parameters for UpdateUserMutation"
    input: UpdateUserMutationInput!
  ): UpdateUserMutationPayload
  updateUserDetail(
    "Parameters for UpdateUserDetailMutation"
    input: UpdateUserDetailMutationInput!
  ): UpdateUserDetailMutationPayload
}
"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}
type Query {
  accounts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AccountConnection
  relation(counterUserId: Int!): Relation
  relations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,positionStatus: RelationPositionCategory!  ): RelationConnection
  talkRooms(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TalkRoomConnection
  talks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,relationId: Int!  ): TalkConnection
  user(userId: Int!): User
  users(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection
}
type Relation {
  actionADate: ISO8601DateTime
  actionBDate: ISO8601DateTime
  actionCDate: ISO8601DateTime
  id: Int
  nextStatuses: [RelationCategory!]
  positionStatus: RelationPositionCategory
  user: User
}
"The connection type for Relation."
type RelationConnection {
  "A list of edges."
  edges: [RelationEdge]
  "A list of nodes."
  nodes: [Relation]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type RelationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Relation
}
type Talk {
  createdAt: ISO8601DateTime!
  id: Int
  message: String
  status: EnabledCategory
  submitter: SubmitterCategory
  updatedAt: ISO8601DateTime!
}
"The connection type for Talk."
type TalkConnection {
  "A list of edges."
  edges: [TalkEdge]
  "A list of nodes."
  nodes: [Talk]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TalkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Talk
}
type TalkRoom {
  lastTalk: Talk
  relation: Relation
}
"The connection type for TalkRoom."
type TalkRoomConnection {
  "A list of edges."
  edges: [TalkRoomEdge]
  "A list of nodes."
  nodes: [TalkRoom]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TalkRoomEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TalkRoom
}
"Autogenerated return type of UpdateRelationMutation"
type UpdateRelationMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  relation: Relation
}
"Autogenerated return type of UpdateTalkMutation"
type UpdateTalkMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  talk: Talk
}
"Autogenerated return type of UpdateUserDetailMutation"
type UpdateUserDetailMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  user: User
}
"Autogenerated return type of UpdateUserMutation"
type UpdateUserMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  user: User
}
type User {
  age: Int
  createdAt: ISO8601DateTime!
  detail: UserDetail
  firstName: String
  gender: GenderCategory
  id: Int
  lastName: String
  updatedAt: ISO8601DateTime!
  userType: UserCategory
}
"The connection type for User."
type UserConnection {
  "A list of edges."
  edges: [UserEdge]
  "A list of nodes."
  nodes: [User]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
type UserDetail {
  createdAt: ISO8601DateTime!
  descriptionA: String
  updatedAt: ISO8601DateTime!
}
"An edge in a connection."
type UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User
}
enum AccountCategory {
  owned
  google
  facebook
}
enum ActiveCategory {
  active
  deactive
  banned
}
enum EnabledCategory {
  enabled
  disabled
}
enum GenderCategory {
  male
  female
}
enum RelationCategory {
  pending
  withdraw
  accepted
  declined
  disconnected
  refused
}
enum RelationPositionCategory {
  pending_me
  pending_you
  withdraw_me
  accepted_me
  accepted_you
  declined_me
  declined_you
  disconnected_me
  disconnected_you
  refused_me
  refused_you
}
enum SubmitterCategory {
  relation_from
  relation_to
}
enum UserCategory {
  admin
  general
}
"Autogenerated input type of CreateRelationMutation"
input CreateRelationMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userId: Int!
}
"Autogenerated input type of CreateTalkMutation"
input CreateTalkMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  relationId: Int!
  message: String!
}
"Autogenerated input type of LoginMutation"
input LoginMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  email: String!
  password: String!
}
"Autogenerated input type of LogoutMutation"
input LogoutMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of UpdateRelationMutation"
input UpdateRelationMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userId: Int!
  status: RelationCategory
}
"Autogenerated input type of UpdateTalkMutation"
input UpdateTalkMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  talkId: Int!
  message: String
  status: EnabledCategory
}
"Autogenerated input type of UpdateUserDetailMutation"
input UpdateUserDetailMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userId: Int!
  description: String
}
"Autogenerated input type of UpdateUserMutation"
input UpdateUserMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userId: Int!
  firstName: String
  lastName: String
  age: Int
  gender: GenderCategory
}
"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT
